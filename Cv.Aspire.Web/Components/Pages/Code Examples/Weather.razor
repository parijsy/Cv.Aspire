@page "/weather"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@using Cv.Aspire.Web.Code.Clients.Api
@using Cv.Aspire.Web.Code.Clients.Api.Models

<PageTitle>Weather</PageTitle>

<div class="container">
    <div class="row">
        <div class="col">
            <h1>Weerbericht</h1>
            <p>
                Dit weerbericht component dient als voorbeeld van een API endpoint.
                Er kan gezocht worden op een plaatsnaam, en indien er een resultaat is dan wordt het huidige weer voor de plaats getoond.
                Onder toelichting duiken we dieper in de werking van de het API endpoint.
                De frontend laten we buiten beschouwing.
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col-auto">
            <InputText class="form-control" placeholder="Locatie" @bind-Value="locationQuery" @onkeyup="OnKeyUp_Search"/>
        </div>
        <div class="col-auto">
            <button class="btn btn-primary mb-3" @onclick="Submit">Zoek</button>
        </div>
    </div>
    <div class="row">
        <div class="col">
            @if (isLoading)
            {
                <p><em>Laden...</em></p>
            }
            else if (forecast is null)
            {
                <p><em>Geen resultaten voor '@locationQuery'</em></p>
            }
            else
            {
                <table class="table">
                    <thead>
                        <tr>
                            <th>Plaats</th>
                            <th>Temperatuur</th>
                            <th>Regen</th>
                            <th>Weer</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>@forecast.Location.Name</td>
                            <td>@(forecast.WeatherForecast.Current.Temperature2m)@(forecast.WeatherForecast.CurrentUnits.Temperature2m)</td>
                            <td>@(forecast.WeatherForecast.Current.Rain)@(forecast.WeatherForecast.CurrentUnits.Rain)</td>
                            <td>@ConvertWmoCode(forecast.WeatherForecast.Current.WeatherCode)</td>
                        </tr>
                    </tbody>
                </table>
            }
        </div>
    </div>

    <div style="margin:0; padding:0; height:100px;"></div>

    <div class="row">
        <div class="col">
            <h2>Toelichting</h2>
            <p>
                De API die wordt gebruikt voor het ophalen van het weerbericht verwacht als input GPS coördinaten.
                Het endpoint dat is gemaakt voor deze pagina voert daardoor twee acties uit.
                Eerst wordt de plaatsnaam omgezet naar coördinaten, en daarna wordt het weerbericht opgehaald voor de betreffende coördinaten.
            </p>
            <p>
                Het endpoint dat wij hebben gedefiniëerd is geplaatst in de <code>WeatherController</code> van onze API.
                Het pad van het endpoint is opgebouwd via de <code>Route</code> attributen.
                De controller doet bewust weinig werk, er wordt een service methode aangeroepen die de data ophaald en deze data wordt omgezet naar een <code>ActionResult</code> via de <code>ToActionResult</code> extension-method.
                De <code>ToActionResult</code> extension-method is een helper methode van de package <code><a href="https://github.com/altmann/FluentResults">FluentResults</a></code> dat binnen dit project wordt gebruikt om het Result-pattern toe te passen.
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService%2FControllers%2FWeatherController.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
            <p>
                De service gaat de twee benodigde acties uitvoeren.
                De plaatsnaam omzetten naar coördinaten, en het weerbericht voor de coördinaten ophalen.
                Voor beide acties wordt er gebruik gemaakt van een externe API.
                Het omzetten van de plaatsnaam naar coördinaten verloopt via een API die een zoek-functie aanbied.
                Omdat het een zoek-functie betreft kunnen er meerdere resultaten terug komen.
                Gelukkig is de beste match het eerste resultaat, waardoor we altijd dat eerste resultaat kunnen gebruiken voor het omzetten van de plaatsnaam naar coördinaten.
                Indien er geen resultaten terugkomen dan geven we een leeg <code>Result&lt;CurrentWeatherForecast?&gt;</code> terug om aan te geven dat er successvol is gezocht, maar dat er geen resultaat is.
                In het geval dat de aanroep naar de externe API faalt dan geven we een <code>Error</code> terug om aan te geven dat er een fout is opgetreden tijdens het proces.
                De <code>ToActionResult</code> extension-method in de controller zal in het geval van een leeg result object een httpstatus code terug geven in de 200 reeks, en in het geval van een error een code in de 500 reeks.
                Nu dat we de coördinaten hebben kunnen we het weerbericht ophalen.
                Het ophalen van het weerbericht is erg rechttoe rechtaan doordat de aanroep naar de externe API is gewrapped in een client klasse.
                Na een <code>IsFailed</code> controle wordt er een <code>CurrentWeatherForecast</code> object aangemaakt dat de responses van beide externe API calls bevat.
                Doordat we beide responses teruggeven geven we de frontend genoeg vrijheid om te kiezen wat ze willen tonen.
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Domain%2FWeather%2FWeatherService.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
            <p>
                De twee clients die de aanroepen doen naar de externe API's lijken erg veel op elkaar aangezien ze allebei een eenvoudige <code>GET</code> uitvoeren, de json response mappen naar modellen en het resultaat teruggeven.
                Omdat we in dit project met het result pattern werken is de request naar de externe API in een try-catch geplaatst omdat een http-request altijd kan falen, de externe API kan bijvoorbeeld tijdelijk niet beschikbaar zijn.
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Domain%2FWeather%2FClients%2FGeocoding%2FGeocodingClient.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Domain%2FWeather%2FClients%2FWeatherForecast%2FWeatherForecastClient.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
        </div>
    </div>
    <div class="row">
        <div class="col">
            <h2>Dependency Injection registraties</h2>
            <p>
                Bij het opstellen van de dependency injection container moet je alle dependencies registreren. Dit kun je direct in de <code>Program.cs</code> doen met het gevolg dat dit bestand even snel groeit als het aantal dependencies die je in je applicatie hebt.
                Het registreren van de dependencies wordt daarom regelmatig verplaatst naar een eigen bestand dat tijdens het bouwen van de container wordt aangeroepen.
                Als alle registraties naar één enkel bestand worden verplaatst dan krijgt dat bestand heel veel usings, of de namespaces worden tijdens de registratie uitgeschreven om conflicten te voorkomen.
                Een vervolg stap is om de registraties te versplinteren naar meerdere kleine bestanden, het gevolg daarvan is dat je die kleinere registratie bestanden moet aanroepen bij het aanmaken van de dependency injection container. 
                Met behulp van reflection is het mogelijk om ervoor te zorgen dat die kleine registratie bestanden tijdens het bouwen van de dependency injection container worden gevonden en uitgevoerd.
            </p>
            <p>
                Om ervoor te zorgen dat we met reflection de registratie bestanden kunnen vinden introduceren we een interface.
                De interface die we introduceren kunnen we <code>IServiceRegistrationBundle</code> noemen, het is namelijk een bundel van service registraties.
                Met de introductie van een interface kunnen we de registratie bundels vinden, maar als we de bundels willen gebruiken is het handig om op de interface één of meerdere signatures definiëren.
                Een voor de hand liggende naam voor de signature is <code>Register</code> en om ervoor te zorgen dat de <code>IServiceCollection</code> aangepast kan worden willen we een <code>IServiceCollection</code> parameter aan de signature toevoegen.
                Met de signature <code>public void Register(IServiceCollection services)</code> kunnen we al veel registraties uitvoeren.
                Om registraties die de configuratie van de applicatie gebruiken mogelijk te maken kunnen we een extra signature toevoegen die als extra parameter een <code>IConfiguration</code> object ontvangt, uiteraard is het ook mogelijk om er voor te kiezen om maar één signature te hebben door de signature zonder <code>IConfiguration</code> te laten vervallen.
            </p>
            <p>
                Dit is de <code>IServiceRegistrationBundle</code> die in dit project wordt gebruikt.
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Infrastructure%2FConfiguration%2FIServiceRegistrationBundle.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showFullPath=on&showCopy=on"></script>
            </p>
            <p>
                De interface wordt in dit project op deze manier gebruikt:
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Domain%2FWeather%2FServiceRegistrationBundle.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
            <p>
                In dit voorbeeld worden er twee opmerkelijke registraties gedaan. De <code>AddHttpClient</code> registraties maken geen gebruik van de overload waarbij het <code>BaseAddress</code> van de httpclient wordt ingesteld.
                De <code>BaseAddress</code> wordt via de custom <code>WithBaseAddress</code> extension-method ingesteld waardoor de registratie net wat beknopter wordt.
                De definitie van deze extension-method ziet er als volgt uit:
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Infrastructure%2FConfiguration%2FHttpClientBuilderExtensions.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
            <p>
                We gaan ons nu richten op het reflection stuk dat ervoor zorgt dat de bundels gevonden en uitgevoerd worden.
                Wat we niet willen is een lap code met reflection bij het aanmaken van de dependency injection container, daarom maken we een extension-method voor <code>IServiceCollection</code>.
                Het enige wat deze extension-method hoeft te doen is alle implementaties van de interface te vinden, en vervolgens de <code>Register</code> methode aan te roepen.
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService.Infrastructure%2FConfiguration%2FServiceCollectionExtensions.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
            <p>
                In dit project wordt de dependency injection container opgebouwd in het <code>Program.cs</code> bestand.
                Als we dit bestand bekijken dan zien we dat de <code>RegisterBundlesInAssembly</code> extension-method wordt gebruikt om alle bestanden binnen de assembly van de Domain project laag te registreren.
                <script src="https://emgithub.com/embed-v2.js?target=https%3A%2F%2Fgithub.com%2Fparijsy%2FCv.Aspire%2Fblob%2Fmaster%2FCv.Aspire.ApiService%2FProgram.cs&style=default&type=code&showBorder=on&showLineNumbers=on&showFileMeta=on&showCopy=on"></script>
            </p>
        </div>
    </div>
</div>